# 格斗机器人总框架设计文档

## 目录

- [一、系统概述](#一系统概述)
  - 1.1 硬件平台
  - 1.2 设计原则
  - 1.3 为什么选择裸机架构
- [二、双工作模式](#二双工作模式)
  - 2.1 战斗模式（Combat Mode）
  - 2.2 收集模式（Collect Mode）
  - 2.3 模式切换逻辑
- [三、传感器配置](#三传感器配置)
  - 3.1 灰度传感器布局
  - 3.2 红外测距传感器布局
  - 3.3 红外避障传感器布局
- [四、位置检测算法](#四位置检测算法)
  - 4.1 台上/台下检测
  - 4.2 三轨道区域划分
  - 4.3 擂台方向识别
- [五、状态机设计](#五状态机设计)
  - 5.1 战斗模式状态机
  - 5.2 收集模式状态机
  - 5.3 状态转换图
- [六、核心功能实现](#六核心功能实现)
  - 6.1 软启动
  - 6.2 登台逻辑
  - 6.3 掉台恢复逻辑
  - 6.4 边缘检测与避让
  - 6.5 敌人检测与攻击
  - 6.6 能量块识别与推送
- [七、软件架构](#七软件架构)
  - 7.1 主循环结构
  - 7.2 定时器中断（2ms）
  - 7.3 DMA配置
  - 7.4 文件结构
- [八、关键参数配置](#八关键参数配置)
  - 8.1 灰度阈值
  - 8.2 PID参数
  - 8.3 距离阈值
- [九、调试接口](#九调试接口)

---

## 一、系统概述

### 1.1 硬件平台

| 组件 | 型号 | 功能 |
|------|------|------|
| 主控制器 | STM32F407VET6 | 实时控制、传感器采集、电机驱动 |
| 视觉处理器 | OrangePi AIpro + 昇腾310B1 | AprilTag识别（仅收集模式使用） |
| 电机驱动 | 双路H桥驱动 | 控制两个驱动轮 |
| 灰度传感器 | 4路模拟输出 | 边缘检测、区域识别 |
| 红外测距 | 前方/后方各1路 | 敌人距离检测 |
| 红外避障 | 左右各1路 | 侧方障碍物检测 |

**通信接口：**
- STM32 ↔ OrangePi：UART（115200bps）
- 传感器采集：ADC + DMA
- 编码器：TIM encoder mode

### 1.2 设计原则

1. **实时性优先**：关键控制逻辑在2ms定时器中断中执行，确保响应速度
2. **简洁可靠**：裸机架构，减少系统复杂度，降低故障点
3. **模块化设计**：传感器、电机、状态机独立模块，便于调试和维护
4. **双模式分离**：战斗模式与收集模式独立状态机，避免逻辑混乱

### 1.3 为什么选择裸机架构

经过评估，本项目**不使用FreeRTOS**，原因如下：

| 对比项 | FreeRTOS | 裸机架构 |
|--------|----------|----------|
| 实时控制 | 任务切换有延迟 | 中断直接执行，延迟最小 |
| 系统复杂度 | 需管理任务、队列、信号量 | 简单的主循环+中断 |
| 调试难度 | 多任务调试困难 | 线性执行，易于追踪 |
| 代码体积 | 额外RTOS开销 | 精简，资源利用率高 |
| 任务特性 | 适合真正并行任务 | 本项目任务实际是顺序执行 |

**核心理由：**

1. **实时控制已在中断中完成**：边缘检测、PID控制、编码器读取等关键操作在2ms定时器中断中执行，不依赖RTOS调度
2. **任务本质是顺序的**：读传感器→决策→执行动作，这是一个顺序流程，不需要真正的并行
3. **视觉处理已卸载**：AprilTag识别由OrangePi处理，STM32只接收结果，无需多任务
4. **可靠性要求高**：格斗比赛中，系统稳定性比功能丰富更重要

**裸机架构核心结构：**

```
┌─────────────────────────────────────────────────────────┐
│                    2ms 定时器中断                        │
│  ┌─────────────┬─────────────┬─────────────────────┐   │
│  │ 灰度采集    │ 编码器读取  │ PID计算 + PWM输出   │   │
│  └─────────────┴─────────────┴─────────────────────┘   │
└─────────────────────────────────────────────────────────┘
                          ↓ 更新全局变量
┌─────────────────────────────────────────────────────────┐
│                      主循环 (while)                      │
│  ┌──────────┬──────────┬──────────┬──────────────────┐ │
│  │ 读传感器 │ 位置检测 │ 状态机   │ 串口通信(视觉)   │ │
│  └──────────┴──────────┴──────────┴──────────────────┘ │
└─────────────────────────────────────────────────────────┘
```

## 二、双工作模式

根据比赛规则，机器人需要完成两类任务：将对方推下擂台（战斗）和推送能量块得分（收集）。这两类任务对传感器的需求不同，因此设计**双工作模式**架构。

### 2.1 战斗模式（Combat Mode）

**目标**：检测敌人、攻击推挤、避免掉台

**传感器使用**：仅使用板载传感器，**不启用视觉模块**

| 传感器 | 用途 |
|--------|------|
| 灰度传感器×4 | 边缘检测、区域判断、台上/台下识别 |
| 前向红外测距 | 检测正前方敌人距离 |
| 后向红外测距 | 检测后方敌人（用于反向攻击） |
| 左右红外避障 | 检测侧方障碍物/敌人 |

**状态列表**：
```c
typedef enum {
    COMBAT_INIT,           // 初始化，等待软启动
    COMBAT_CLIMB,          // 登台
    COMBAT_SEARCH,         // 搜索敌人
    COMBAT_APPROACH,       // 接近敌人
    COMBAT_ATTACK,         // 全速攻击
    COMBAT_EVADE,          // 边缘回避
    COMBAT_RECOVER,        // 掉台恢复
    COMBAT_STUCK           // 卡住处理
} CombatState_t;
```

**战斗模式流程图**：
```
                    ┌──────────────┐
                    │  COMBAT_INIT │
                    └──────┬───────┘
                           │ 红外触发软启动
                    ┌──────▼───────┐
                    │ COMBAT_CLIMB │
                    └──────┬───────┘
                           │ 登台成功
         ┌─────────────────▼─────────────────┐
         │           COMBAT_SEARCH           │
         │         (旋转扫描敌人)             │
         └─────────────────┬─────────────────┘
                           │ 检测到敌人
                    ┌──────▼───────┐
                    │COMBAT_APPROACH│
                    └──────┬───────┘
                           │ 距离足够近
                    ┌──────▼───────┐
        ┌───────────│COMBAT_ATTACK │───────────┐
        │           └──────────────┘           │
        │ 检测到边缘                    丢失敌人 │
  ┌─────▼─────┐                         ┌──────▼──────┐
  │COMBAT_EVADE│                         │返回 SEARCH  │
  └─────┬─────┘                         └─────────────┘
        │ 回避完成
        └──────────► 返回 SEARCH
```

### 2.2 收集模式（Collect Mode）

**目标**：识别己方能量块、推送至得分区

**传感器使用**：板载传感器 + **视觉模块**

| 传感器 | 用途 |
|--------|------|
| 灰度传感器×4 | 边缘检测、区域判断 |
| 视觉模块 | AprilTag识别（ID 0/1/2） |
| 红外测距 | 辅助接近能量块 |

**AprilTag编码**（比赛规则）：
| Tag ID | 含义 | 处理方式 |
|--------|------|----------|
| 0 | 中性能量块 | 可推送得分 |
| 1 | 蓝方能量块 | 蓝方机器人推送得分 |
| 2 | 黄方能量块 | 黄方机器人推送得分 |

**状态列表**：
```c
typedef enum {
    COLLECT_INIT,          // 初始化
    COLLECT_CLIMB,         // 登台
    COLLECT_SCAN,          // 视觉扫描能量块
    COLLECT_APPROACH,      // 接近目标能量块
    COLLECT_ALIGN,         // 对准能量块
    COLLECT_PUSH,          // 推送至边缘
    COLLECT_EVADE,         // 边缘回避
    COLLECT_RECOVER        // 掉台恢复
} CollectState_t;
```

**收集模式流程图**：
```
                    ┌──────────────┐
                    │ COLLECT_INIT │
                    └──────┬───────┘
                           │ 红外触发软启动
                    ┌──────▼───────┐
                    │ COLLECT_CLIMB│
                    └──────┬───────┘
                           │ 登台成功
         ┌─────────────────▼─────────────────┐
         │           COLLECT_SCAN            │
         │      (视觉扫描AprilTag)           │
         └─────────────────┬─────────────────┘
                           │ 检测到目标Tag
                    ┌──────▼───────┐
                    │COLLECT_APPROACH│
                    └──────┬───────┘
                           │ 接近完成
                    ┌──────▼───────┐
                    │ COLLECT_ALIGN│
                    └──────┬───────┘
                           │ 对准完成
                    ┌──────▼───────┐
                    │ COLLECT_PUSH │──────► 推送成功 ──► 返回 SCAN
                    └──────────────┘
```

### 2.3 模式切换逻辑

**模式选择**：通过物理开关或上位机指令在比赛前设定

```c
typedef enum {
    MODE_COMBAT,    // 战斗模式
    MODE_COLLECT    // 收集模式
} WorkMode_t;

volatile WorkMode_t g_work_mode = MODE_COMBAT;  // 默认战斗模式
```

**模式切换时机**：
- **赛前设定**：根据比赛策略选择模式
- **运行中不切换**：为保证稳定性，比赛过程中不进行模式切换

**模式差异对比**：

| 特性 | 战斗模式 | 收集模式 |
|------|----------|----------|
| 视觉模块 | ❌ 不使用 | ✅ 使用 |
| 主要目标 | 推挤敌人 | 推送能量块 |
| 运动策略 | 激进、高速 | 精确、稳定 |
| 边缘处理 | 快速回避 | 谨慎推送 |
| 电机功率 | 全功率攻击 | 中等功率 |

**主循环模式分发**：
```c
void main_loop(void) {
    // 读取传感器
    Sensor_Update();

    // 位置检测
    Location_Update();

    // 根据模式执行不同状态机
    switch (g_work_mode) {
        case MODE_COMBAT:
            Combat_StateMachine();
            break;
        case MODE_COLLECT:
            Collect_StateMachine();
            Vision_Process();  // 仅收集模式处理视觉数据
            break;
    }

    // 电机输出
    Motor_Output();
}
```

## 三、传感器配置

### 3.1 灰度传感器布局

**数量**：4路模拟输出灰度传感器

**安装位置**：机器人底盘四角，距地面约3-5mm

```
        前进方向 ↑
    ┌─────────────────┐
    │  ┌───┐   ┌───┐  │
    │  │LF │   │ RF│  │  LF = Left Front  (左前)
    │  └───┘   └───┘  │  RF = Right Front (右前)
    │                 │
    │     [机器人]    │
    │                 │
    │  ┌───┐   ┌───┐  │
    │  │LB │   │ RB│  │  LB = Left Back   (左后)
    │  └───┘   └───┘  │  RB = Right Back  (右后)
    └─────────────────┘
```

**硬件接口**：
```c
// ADC通道定义
#define GRAY_LF_CHANNEL    ADC_CHANNEL_0   // PA0
#define GRAY_RF_CHANNEL    ADC_CHANNEL_1   // PA1
#define GRAY_LB_CHANNEL    ADC_CHANNEL_2   // PA2
#define GRAY_RB_CHANNEL    ADC_CHANNEL_3   // PA3

// 灰度数据结构
typedef struct {
    uint16_t lf;    // 左前
    uint16_t rf;    // 右前
    uint16_t lb;    // 左后
    uint16_t rb;    // 右后
    uint16_t avg;   // 平均值
    uint16_t variance;  // 方差（用于台上/台下判断）
} GraySensor_t;

volatile GraySensor_t g_gray;
```

**功能说明**：

| 功能 | 实现方式 |
|------|----------|
| 边缘检测 | 任一传感器读数 < 黑色阈值 → 接近边缘 |
| 区域判断 | 根据平均值判断处于中心/中间/边缘区域 |
| 台上/台下识别 | 方差分析：台上有渐变（方差大），台下纯黑（方差小） |
| 方向判断 | 比较四个传感器读数，判断擂台相对方向 |

### 3.2 红外测距传感器布局

**数量**：2路（前向 + 后向）

**型号建议**：GP2Y0A21YK（10-80cm）或类似模拟输出测距传感器

**安装位置**：
```
              前向红外测距
                  ↓
              ┌───────┐
              │  ▲IR  │
        ┌─────┴───────┴─────┐
        │                   │
        │     [机器人]      │
        │                   │
        └─────┬───────┬─────┘
              │  ▼IR  │
              └───────┘
                  ↑
              后向红外测距
```

**硬件接口**：
```c
// ADC通道定义
#define IR_FRONT_CHANNEL   ADC_CHANNEL_4   // PA4
#define IR_BACK_CHANNEL    ADC_CHANNEL_5   // PA5

// 红外测距数据结构
typedef struct {
    uint16_t front_raw;     // 前向原始ADC值
    uint16_t back_raw;      // 后向原始ADC值
    uint16_t front_dist;    // 前向距离（mm）
    uint16_t back_dist;     // 后向距离（mm）
    uint8_t front_detect;   // 前方是否检测到物体
    uint8_t back_detect;    // 后方是否检测到物体
} IRDistance_t;

volatile IRDistance_t g_ir_dist;
```

**距离转换**（需根据实际传感器标定）：
```c
// GP2Y0A21YK 近似转换公式
uint16_t IR_ADC_to_Distance(uint16_t adc_value) {
    if (adc_value < 80) return 800;  // 超出范围
    // 距离(mm) ≈ 27000 / (adc_value - 20)
    return (uint16_t)(27000 / (adc_value - 20));
}
```

**功能说明**：

| 功能 | 判断条件 |
|------|----------|
| 前方敌人检测 | front_dist < 300mm |
| 后方敌人检测 | back_dist < 300mm |
| 攻击距离判断 | front_dist < 150mm → 进入全速攻击 |
| 能量块接近 | front_dist < 100mm → 开始推送 |

### 3.3 红外避障传感器布局

**数量**：2路（左侧 + 右侧）

**类型**：数字输出红外避障模块（有障碍=低电平，无障碍=高电平）

**安装位置**：
```
        ┌─────────────────┐
        │                 │
   ←IR──┤     [机器人]    ├──IR→
   左侧  │                 │  右侧
        └─────────────────┘
```

**硬件接口**：
```c
// GPIO定义
#define IR_LEFT_PORT       GPIOB
#define IR_LEFT_PIN        GPIO_PIN_0
#define IR_RIGHT_PORT      GPIOB
#define IR_RIGHT_PIN       GPIO_PIN_1

// 避障数据结构
typedef struct {
    uint8_t left;    // 左侧检测：1=有障碍, 0=无障碍
    uint8_t right;   // 右侧检测：1=有障碍, 0=无障碍
} IRObstacle_t;

volatile IRObstacle_t g_ir_obs;

// 读取函数
void IR_Obstacle_Read(void) {
    g_ir_obs.left  = !HAL_GPIO_ReadPin(IR_LEFT_PORT, IR_LEFT_PIN);
    g_ir_obs.right = !HAL_GPIO_ReadPin(IR_RIGHT_PORT, IR_RIGHT_PIN);
}
```

**功能说明**：

| 检测结果 | 含义 | 动作 |
|----------|------|------|
| 左=1, 右=0 | 左侧有障碍 | 右转避让或左转攻击 |
| 左=0, 右=1 | 右侧有障碍 | 左转避让或右转攻击 |
| 左=1, 右=1 | 两侧都有障碍 | 可能被夹击，后退 |
| 左=0, 右=0 | 两侧无障碍 | 正常行驶 |

### 3.4 传感器采集汇总

**DMA + ADC配置**：

```c
// ADC DMA缓冲区
#define ADC_CHANNEL_COUNT  6
uint16_t g_adc_buffer[ADC_CHANNEL_COUNT];

// 通道顺序
// [0] = GRAY_LF, [1] = GRAY_RF, [2] = GRAY_LB, [3] = GRAY_RB
// [4] = IR_FRONT, [5] = IR_BACK
```

**采集时序**（2ms定时器中断）：

```c
void TIM2_IRQHandler(void) {
    if (__HAL_TIM_GET_FLAG(&htim2, TIM_FLAG_UPDATE)) {
        __HAL_TIM_CLEAR_FLAG(&htim2, TIM_FLAG_UPDATE);

        // 1. 从DMA缓冲区读取ADC数据
        g_gray.lf = g_adc_buffer[0];
        g_gray.rf = g_adc_buffer[1];
        g_gray.lb = g_adc_buffer[2];
        g_gray.rb = g_adc_buffer[3];
        g_ir_dist.front_raw = g_adc_buffer[4];
        g_ir_dist.back_raw = g_adc_buffer[5];

        // 2. 计算灰度平均值和方差
        Gray_Calculate();

        // 3. 转换红外距离
        g_ir_dist.front_dist = IR_ADC_to_Distance(g_ir_dist.front_raw);
        g_ir_dist.back_dist = IR_ADC_to_Distance(g_ir_dist.back_raw);

        // 4. 读取数字IO（红外避障）
        IR_Obstacle_Read();

        // 5. 读取编码器
        Encoder_Read();

        // 6. PID计算并输出PWM
        Motor_PID_Update();
    }
}
```

**传感器数据结构汇总**：

```c
// 所有传感器数据的全局结构
typedef struct {
    GraySensor_t gray;       // 灰度传感器
    IRDistance_t ir_dist;    // 红外测距
    IRObstacle_t ir_obs;     // 红外避障
    int32_t encoder_left;    // 左编码器计数
    int32_t encoder_right;   // 右编码器计数
} SensorData_t;

volatile SensorData_t g_sensors;
```

## 四、位置检测算法

### 4.1 台上/台下检测

**原理**：擂台表面是从中心（白/红）到边缘（黑）的渐变色，而台下地面是纯黑色。利用**灰度方差**区分两种情况。

| 位置 | 灰度特征 | 方差特征 |
|------|----------|----------|
| 台上 | 四个传感器读数有差异（渐变） | 方差较大（> 阈值） |
| 台下 | 四个传感器读数接近（纯黑） | 方差很小（< 阈值） |

**实现代码**：

```c
// 位置状态枚举
typedef enum {
    LOCATION_ON_ARENA,      // 在擂台上
    LOCATION_OFF_ARENA,     // 在擂台下（掉台）
    LOCATION_CLIMBING       // 正在登台过程中
} LocationState_t;

volatile LocationState_t g_location = LOCATION_OFF_ARENA;

// 方差计算
void Gray_Calculate(void) {
    // 计算平均值
    uint32_t sum = g_gray.lf + g_gray.rf + g_gray.lb + g_gray.rb;
    g_gray.avg = sum / 4;

    // 计算方差
    int32_t diff_lf = (int32_t)g_gray.lf - g_gray.avg;
    int32_t diff_rf = (int32_t)g_gray.rf - g_gray.avg;
    int32_t diff_lb = (int32_t)g_gray.lb - g_gray.avg;
    int32_t diff_rb = (int32_t)g_gray.rb - g_gray.avg;

    g_gray.variance = (diff_lf * diff_lf + diff_rf * diff_rf +
                       diff_lb * diff_lb + diff_rb * diff_rb) / 4;
}

// 台上/台下判断
#define VARIANCE_THRESHOLD_LOW   100   // 方差低阈值（台下）
#define GRAY_BLACK_THRESHOLD     500   // 纯黑阈值

void Location_Detect(void) {
    // 条件1：所有传感器都是纯黑
    uint8_t all_black = (g_gray.lf < GRAY_BLACK_THRESHOLD) &&
                        (g_gray.rf < GRAY_BLACK_THRESHOLD) &&
                        (g_gray.lb < GRAY_BLACK_THRESHOLD) &&
                        (g_gray.rb < GRAY_BLACK_THRESHOLD);

    // 条件2：方差很小
    uint8_t low_variance = (g_gray.variance < VARIANCE_THRESHOLD_LOW);

    // 两个条件都满足 → 判定为台下
    if (all_black && low_variance) {
        g_location = LOCATION_OFF_ARENA;
    } else {
        g_location = LOCATION_ON_ARENA;
    }
}
```

**状态转换图**：

```
                    开机
                      │
                      ▼
              ┌───────────────┐
              │ LOCATION_OFF  │ ◄──────────────┐
              │   (台下)      │                │
              └───────┬───────┘                │
                      │ 登台成功               │ 掉台检测
                      │ (方差变大)             │ (全黑+低方差)
                      ▼                        │
              ┌───────────────┐                │
              │ LOCATION_ON   │ ───────────────┘
              │   (台上)      │
              └───────────────┘
```

### 4.2 三轨道区域划分

**原理**：根据参考文章的"三轨道策略"，将擂台划分为三个区域，不同区域采用不同运动策略。

```
┌─────────────────────────────────────────────┐
│ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ │  ← 边缘区（黑色）
│ ▓                                         ▓ │     ZONE_EDGE
│ ▓   ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░   ▓ │  ← 中间区（灰色渐变）
│ ▓   ░                                 ░   ▓ │     ZONE_MIDDLE
│ ▓   ░   ┌─────────────────────┐     ░   ▓ │
│ ▓   ░   │                     │     ░   ▓ │  ← 中心区（白/红色）
│ ▓   ░   │      CENTER         │     ░   ▓ │     ZONE_CENTER
│ ▓   ░   │                     │     ░   ▓ │
│ ▓   ░   └─────────────────────┘     ░   ▓ │
│ ▓   ░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░   ▓ │
│ ▓                                         ▓ │
│ ▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓▓ │
└─────────────────────────────────────────────┘
```

**区域定义与策略**：

| 区域 | 灰度范围 | 运动策略 | 危险等级 |
|------|----------|----------|----------|
| CENTER（中心） | avg > 3000 | 自由移动，可全速攻击 | ⭐ 安全 |
| MIDDLE（中间） | 1500 < avg ≤ 3000 | 正常移动，注意方向 | ⭐⭐ 一般 |
| EDGE（边缘） | avg ≤ 1500 | 立即回避，禁止前进 | ⭐⭐⭐ 危险 |

**实现代码**：

```c
// 区域枚举
typedef enum {
    ZONE_CENTER,    // 中心区（安全）
    ZONE_MIDDLE,    // 中间区（一般）
    ZONE_EDGE       // 边缘区（危险）
} TrackZone_t;

volatile TrackZone_t g_zone = ZONE_CENTER;

// 区域阈值（需根据实际擂台标定）
#define GRAY_CENTER_THRESHOLD  3000   // 中心区阈值
#define GRAY_MIDDLE_THRESHOLD  1500   // 中间区阈值

// 区域检测
void Zone_Detect(void) {
    if (g_gray.avg > GRAY_CENTER_THRESHOLD) {
        g_zone = ZONE_CENTER;
    } else if (g_gray.avg > GRAY_MIDDLE_THRESHOLD) {
        g_zone = ZONE_MIDDLE;
    } else {
        g_zone = ZONE_EDGE;
    }
}

// 边缘检测（任意一个传感器触发即为边缘）
#define GRAY_EDGE_TRIGGER  800  // 单传感器边缘触发阈值

typedef struct {
    uint8_t front_left;   // 左前触发
    uint8_t front_right;  // 右前触发
    uint8_t back_left;    // 左后触发
    uint8_t back_right;   // 右后触发
    uint8_t any_edge;     // 任意边缘触发
} EdgeDetect_t;

volatile EdgeDetect_t g_edge;

void Edge_Detect(void) {
    g_edge.front_left  = (g_gray.lf < GRAY_EDGE_TRIGGER);
    g_edge.front_right = (g_gray.rf < GRAY_EDGE_TRIGGER);
    g_edge.back_left   = (g_gray.lb < GRAY_EDGE_TRIGGER);
    g_edge.back_right  = (g_gray.rb < GRAY_EDGE_TRIGGER);

    g_edge.any_edge = g_edge.front_left || g_edge.front_right ||
                      g_edge.back_left  || g_edge.back_right;
}
```

### 4.3 擂台方向识别

**原理**：当机器人掉台后，需要识别擂台在哪个方向，以便执行登台动作。利用四个灰度传感器的**读数差异**判断擂台相对方向。

**方向判断逻辑**：

```
擂台在前方：前侧传感器读数 > 后侧传感器读数
擂台在后方：后侧传感器读数 > 前侧传感器读数
擂台在左侧：左侧传感器读数 > 右侧传感器读数
擂台在右侧：右侧传感器读数 > 左侧传感器读数
```

**实现代码**：

```c
// 擂台方向枚举
typedef enum {
    ARENA_DIR_FRONT,      // 擂台在前方
    ARENA_DIR_BACK,       // 擂台在后方
    ARENA_DIR_LEFT,       // 擂台在左侧
    ARENA_DIR_RIGHT,      // 擂台在右侧
    ARENA_DIR_UNKNOWN     // 无法判断
} ArenaDirection_t;

volatile ArenaDirection_t g_arena_dir = ARENA_DIR_UNKNOWN;

// 方向判断阈值
#define DIR_DIFF_THRESHOLD  200  // 前后/左右差异阈值

void Arena_Direction_Detect(void) {
    // 仅在台下时需要判断方向
    if (g_location != LOCATION_OFF_ARENA) {
        g_arena_dir = ARENA_DIR_UNKNOWN;
        return;
    }

    // 计算前后差异
    int32_t front_avg = (g_gray.lf + g_gray.rf) / 2;
    int32_t back_avg  = (g_gray.lb + g_gray.rb) / 2;
    int32_t fb_diff   = front_avg - back_avg;

    // 计算左右差异
    int32_t left_avg  = (g_gray.lf + g_gray.lb) / 2;
    int32_t right_avg = (g_gray.rf + g_gray.rb) / 2;
    int32_t lr_diff   = left_avg - right_avg;

    // 判断主要方向（取差异较大的方向）
    if (abs(fb_diff) > abs(lr_diff)) {
        // 前后差异更大
        if (fb_diff > DIR_DIFF_THRESHOLD) {
            g_arena_dir = ARENA_DIR_FRONT;
        } else if (fb_diff < -DIR_DIFF_THRESHOLD) {
            g_arena_dir = ARENA_DIR_BACK;
        } else {
            g_arena_dir = ARENA_DIR_UNKNOWN;
        }
    } else {
        // 左右差异更大
        if (lr_diff > DIR_DIFF_THRESHOLD) {
            g_arena_dir = ARENA_DIR_LEFT;
        } else if (lr_diff < -DIR_DIFF_THRESHOLD) {
            g_arena_dir = ARENA_DIR_RIGHT;
        } else {
            g_arena_dir = ARENA_DIR_UNKNOWN;
        }
    }
}
```

### 4.4 位置检测主函数

**整合所有位置检测逻辑**：

```c
void Location_Update(void) {
    // 1. 计算灰度统计量
    Gray_Calculate();

    // 2. 台上/台下检测
    Location_Detect();

    // 3. 区域检测（仅台上有效）
    if (g_location == LOCATION_ON_ARENA) {
        Zone_Detect();
        Edge_Detect();
    }

    // 4. 擂台方向检测（仅台下有效）
    if (g_location == LOCATION_OFF_ARENA) {
        Arena_Direction_Detect();
    }
}
```

**位置信息汇总结构**：

```c
typedef struct {
    LocationState_t location;     // 台上/台下状态
    TrackZone_t zone;             // 三轨道区域
    EdgeDetect_t edge;            // 边缘触发状态
    ArenaDirection_t arena_dir;   // 擂台方向（台下使用）
} PositionInfo_t;

volatile PositionInfo_t g_position;
```

## 五、状态机设计

### 5.1 战斗模式状态机

**状态定义**：

```c
typedef enum {
    COMBAT_INIT,           // 初始化，等待软启动
    COMBAT_CLIMB,          // 登台
    COMBAT_SEARCH,         // 搜索敌人（原地旋转扫描）
    COMBAT_APPROACH,       // 接近敌人
    COMBAT_ATTACK,         // 全速攻击
    COMBAT_EVADE,          // 边缘回避
    COMBAT_RECOVER,        // 掉台恢复
    COMBAT_STUCK           // 卡住处理
} CombatState_t;
```

**状态转换条件**：

| 当前状态 | 转换条件 | 目标状态 |
|----------|----------|----------|
| INIT | 红外触发软启动 | CLIMB |
| CLIMB | 登台成功（检测到台上） | SEARCH |
| SEARCH | 检测到敌人 | APPROACH |
| SEARCH | 超时未找到 | 继续旋转 |
| APPROACH | 距离足够近 | ATTACK |
| APPROACH | 丢失敌人 | SEARCH |
| ATTACK | 检测到边缘 | EVADE |
| ATTACK | 丢失敌人 | SEARCH |
| EVADE | 回避完成 | SEARCH |
| 任意状态 | 检测到掉台 | RECOVER |
| RECOVER | 重新登台成功 | SEARCH |

**状态处理函数框架**：

```c
void Combat_StateMachine(void) {
    // 全局掉台检测（优先级最高）
    if (g_location == LOCATION_OFF_ARENA && g_combat_state != COMBAT_RECOVER) {
        g_combat_state = COMBAT_RECOVER;
    }

    switch (g_combat_state) {
        case COMBAT_INIT:    Combat_Init_Handler();    break;
        case COMBAT_CLIMB:   Combat_Climb_Handler();   break;
        case COMBAT_SEARCH:  Combat_Search_Handler();  break;
        case COMBAT_APPROACH: Combat_Approach_Handler(); break;
        case COMBAT_ATTACK:  Combat_Attack_Handler();  break;
        case COMBAT_EVADE:   Combat_Evade_Handler();   break;
        case COMBAT_RECOVER: Combat_Recover_Handler(); break;
        case COMBAT_STUCK:   Combat_Stuck_Handler();   break;
    }
}
```

### 5.2 收集模式状态机

**状态定义**：

```c
typedef enum {
    COLLECT_INIT,          // 初始化
    COLLECT_CLIMB,         // 登台
    COLLECT_SCAN,          // 视觉扫描能量块
    COLLECT_APPROACH,      // 接近目标能量块
    COLLECT_ALIGN,         // 对准能量块
    COLLECT_PUSH,          // 推送至边缘
    COLLECT_EVADE,         // 边缘回避
    COLLECT_RECOVER        // 掉台恢复
} CollectState_t;
```

**状态转换条件**：

| 当前状态 | 转换条件 | 目标状态 |
|----------|----------|----------|
| INIT | 红外触发软启动 | CLIMB |
| CLIMB | 登台成功 | SCAN |
| SCAN | 检测到目标Tag | APPROACH |
| SCAN | 未检测到 | 继续旋转扫描 |
| APPROACH | 接近完成 | ALIGN |
| ALIGN | 对准完成 | PUSH |
| PUSH | 推送成功（边缘触发） | SCAN |
| PUSH | 检测到边缘 | EVADE |
| EVADE | 回避完成 | SCAN |
| 任意状态 | 检测到掉台 | RECOVER |

**状态处理函数框架**：

```c
void Collect_StateMachine(void) {
    // 全局掉台检测
    if (g_location == LOCATION_OFF_ARENA && g_collect_state != COLLECT_RECOVER) {
        g_collect_state = COLLECT_RECOVER;
    }

    switch (g_collect_state) {
        case COLLECT_INIT:    Collect_Init_Handler();    break;
        case COLLECT_CLIMB:   Collect_Climb_Handler();   break;
        case COLLECT_SCAN:    Collect_Scan_Handler();    break;
        case COLLECT_APPROACH: Collect_Approach_Handler(); break;
        case COLLECT_ALIGN:   Collect_Align_Handler();   break;
        case COLLECT_PUSH:    Collect_Push_Handler();    break;
        case COLLECT_EVADE:   Collect_Evade_Handler();   break;
        case COLLECT_RECOVER: Collect_Recover_Handler(); break;
    }
}
```

### 5.3 状态转换图

**战斗模式状态转换图**：

```
                         ┌─────────────────────────────────────┐
                         │           COMBAT_RECOVER            │
                         │          (掉台恢复)                 │
                         └──────────────┬──────────────────────┘
                                        │ 登台成功
                         ┌──────────────▼──────────────────────┐
     ┌───────────────────│           COMBAT_INIT              │
     │                   │          (等待启动)                 │
     │                   └──────────────┬──────────────────────┘
     │                                  │ 软启动触发
     │                   ┌──────────────▼──────────────────────┐
     │                   │           COMBAT_CLIMB              │
     │                   │            (登台)                   │
     │                   └──────────────┬──────────────────────┘
     │                                  │ 登台成功
     │  ┌───────────────────────────────▼───────────────────────────┐
     │  │                        COMBAT_SEARCH                      │
     │  │                      (搜索敌人-旋转)                       │◄────┐
     │  └───────────────────────────────┬───────────────────────────┘     │
     │                                  │ 检测到敌人                      │
     │                   ┌──────────────▼──────────────────────┐          │
     │                   │          COMBAT_APPROACH            │          │
     │                   │           (接近敌人)                │──────────┤
     │                   └──────────────┬──────────────────────┘ 丢失敌人 │
     │                                  │ 距离足够近                      │
     │                   ┌──────────────▼──────────────────────┐          │
     │                   │           COMBAT_ATTACK             │          │
     │                   │           (全速攻击)                │──────────┤
     │                   └──────────────┬──────────────────────┘ 丢失敌人 │
     │                                  │ 检测到边缘                      │
     │                   ┌──────────────▼──────────────────────┐          │
     │                   │           COMBAT_EVADE              │          │
     │                   │           (边缘回避)                │──────────┘
     │                   └─────────────────────────────────────┘ 回避完成
     │
     │  ════════════════════════════════════════════════════════════
     │                    ↑ 任意状态检测到掉台 → RECOVER
     └──────────────────────────────────────────────────────────────
```

**收集模式状态转换图**：

```
                         ┌─────────────────────────────────────┐
                         │          COLLECT_RECOVER            │
                         │          (掉台恢复)                 │
                         └──────────────┬──────────────────────┘
                                        │ 登台成功
                         ┌──────────────▼──────────────────────┐
                         │          COLLECT_INIT               │
                         │          (等待启动)                 │
                         └──────────────┬──────────────────────┘
                                        │ 软启动触发
                         ┌──────────────▼──────────────────────┐
                         │          COLLECT_CLIMB              │
                         │            (登台)                   │
                         └──────────────┬──────────────────────┘
                                        │ 登台成功
     ┌──────────────────────────────────▼───────────────────────────┐
     │                         COLLECT_SCAN                         │
     │                    (视觉扫描AprilTag)                        │◄────┐
     └──────────────────────────────────┬───────────────────────────┘     │
                                        │ 检测到目标Tag                   │
                         ┌──────────────▼──────────────────────┐          │
                         │         COLLECT_APPROACH            │          │
                         │          (接近能量块)               │          │
                         └──────────────┬──────────────────────┘          │
                                        │ 接近完成                        │
                         ┌──────────────▼──────────────────────┐          │
                         │          COLLECT_ALIGN              │          │
                         │          (对准能量块)               │          │
                         └──────────────┬──────────────────────┘          │
                                        │ 对准完成                        │
                         ┌──────────────▼──────────────────────┐          │
                         │          COLLECT_PUSH               │──────────┘
                         │        (推送至边缘)                 │ 推送成功
                         └──────────────┬──────────────────────┘
                                        │ 检测到边缘
                         ┌──────────────▼──────────────────────┐
                         │          COLLECT_EVADE              │──────────┘
                         │          (边缘回避)                 │ 回避完成
                         └─────────────────────────────────────┘
```

---

## 六、核心功能实现

### 6.1 软启动

采用红外传感器非接触式启动，避免机械开关接触不良。

**启动逻辑**：
```c
typedef enum {
    START_WAIT,      // 等待启动信号
    START_DELAY,     // 延迟启动（5秒倒计时）
    START_RUNNING    // 正常运行
} StartState_t;

void SoftStart_Process(void) {
    static uint32_t start_tick = 0;

    switch (start_state) {
        case START_WAIT:
            if (IR_Obstacle_Left < IR_START_THRESHOLD) {
                start_tick = HAL_GetTick();
                start_state = START_DELAY;
            }
            break;

        case START_DELAY:
            if (HAL_GetTick() - start_tick >= 5000) {
                start_state = START_RUNNING;
                Combat_Init();  // 初始化战斗模式
            }
            break;

        case START_RUNNING:
            // 正常运行，执行状态机
            break;
    }
}
```

### 6.2 登台逻辑

利用后部弧形板，倒车全速冲上6cm高台。

**登台流程**：
1. 检测到台下（灰度方差小）
2. 后退对准擂台
3. 全速倒车冲上擂台
4. 检测到台上后停止

```c
void ClimbArena_Process(void) {
    static uint32_t climb_start_tick = 0;

    if (location_state == LOCATION_OFF_ARENA) {
        // 后退对准擂台
        Motor_SetSpeed(-CLIMB_ALIGN_SPEED, -CLIMB_ALIGN_SPEED);
        HAL_Delay(500);

        // 全速倒车登台
        climb_start_tick = HAL_GetTick();
        Motor_SetSpeed(-CLIMB_MAX_SPEED, -CLIMB_MAX_SPEED);

        // 等待登台完成或超时
        while (location_state != LOCATION_ON_ARENA &&
               HAL_GetTick() - climb_start_tick < CLIMB_TIMEOUT) {
            Location_Update();
        }

        Motor_Stop();
    }
}
```

### 6.3 掉台恢复逻辑

检测到掉台后，执行"前进撞围栏→调整后对擂台→倒车登台"流程。

**恢复流程**：
```c
typedef enum {
    RECOVER_FORWARD,   // 前进撞围栏
    RECOVER_ALIGN,     // 调整后对擂台
    RECOVER_CLIMB      // 倒车登台
} RecoverStep_t;

void FallRecover_Process(void) {
    static RecoverStep_t step = RECOVER_FORWARD;

    switch (step) {
        case RECOVER_FORWARD:
            // 前进撞围栏，确定方向
            Motor_SetSpeed(RECOVER_FORWARD_SPEED, RECOVER_FORWARD_SPEED);
            if (IR_Obstacle_Front < IR_WALL_THRESHOLD) {
                Motor_Stop();
                step = RECOVER_ALIGN;
            }
            break;

        case RECOVER_ALIGN:
            // 后退并调整角度，使后部对准擂台
            Motor_SetSpeed(-RECOVER_ALIGN_SPEED, -RECOVER_ALIGN_SPEED);
            HAL_Delay(800);
            Motor_Stop();
            step = RECOVER_CLIMB;
            break;

        case RECOVER_CLIMB:
            // 倒车登台
            ClimbArena_Process();
            step = RECOVER_FORWARD;  // 重置状态
            break;
    }
}
```

### 6.4 边缘检测与避让

基于三轨道策略，根据当前区域采取不同避让策略。

**避让策略**：
```c
void EdgeAvoid_Process(void) {
    TrackZone_t zone = Location_GetZone();

    switch (zone) {
        case ZONE_CENTER:
            // 中心区域：小幅后退
            Motor_SetSpeed(-EDGE_AVOID_SPEED_LOW, -EDGE_AVOID_SPEED_LOW);
            HAL_Delay(300);
            break;

        case ZONE_MIDDLE:
            // 中间区域：中等后退+转向
            Motor_SetSpeed(-EDGE_AVOID_SPEED_MID, -EDGE_AVOID_SPEED_MID);
            HAL_Delay(500);
            Motor_SetSpeed(EDGE_AVOID_SPEED_MID, -EDGE_AVOID_SPEED_MID);
            HAL_Delay(300);
            break;

        case ZONE_EDGE:
            // 边缘区域：大幅后退+急转
            Motor_SetSpeed(-EDGE_AVOID_SPEED_HIGH, -EDGE_AVOID_SPEED_HIGH);
            HAL_Delay(800);
            Motor_SetSpeed(EDGE_AVOID_SPEED_HIGH, -EDGE_AVOID_SPEED_HIGH);
            HAL_Delay(500);
            break;
    }

    Motor_Stop();
}
```

### 6.5 敌人检测与攻击

使用红外测距传感器检测敌人，根据距离采取不同攻击策略。

**攻击逻辑**：
```c
typedef enum {
    ATTACK_NONE,      // 无目标
    ATTACK_APPROACH,  // 接近
    ATTACK_CHARGE     // 冲撞
} AttackMode_t;

AttackMode_t Enemy_Detect(void) {
    uint16_t dist_left = IR_Distance_Left;
    uint16_t dist_right = IR_Distance_Right;
    uint16_t min_dist = (dist_left < dist_right) ? dist_left : dist_right;

    if (min_dist < ATTACK_CHARGE_DISTANCE) {
        return ATTACK_CHARGE;  // 近距离：全速冲撞
    } else if (min_dist < ATTACK_APPROACH_DISTANCE) {
        return ATTACK_APPROACH;  // 中距离：接近
    } else {
        return ATTACK_NONE;  // 无目标
    }
}

void Attack_Process(void) {
    AttackMode_t mode = Enemy_Detect();

    switch (mode) {
        case ATTACK_CHARGE:
            // 全速冲撞
            Motor_SetSpeed(ATTACK_MAX_SPEED, ATTACK_MAX_SPEED);
            break;

        case ATTACK_APPROACH:
            // 中速接近，根据左右传感器调整方向
            if (IR_Distance_Left < IR_Distance_Right) {
                Motor_SetSpeed(ATTACK_APPROACH_SPEED, ATTACK_APPROACH_SPEED * 0.7);
            } else {
                Motor_SetSpeed(ATTACK_APPROACH_SPEED * 0.7, ATTACK_APPROACH_SPEED);
            }
            break;

        case ATTACK_NONE:
            // 搜索模式：原地旋转
            Motor_SetSpeed(SEARCH_SPEED, -SEARCH_SPEED);
            break;
    }
}
```

### 6.6 能量块识别与推送

收集模式下，通过视觉系统识别AprilTag，推送能量块至擂台边缘。

**识别与推送流程**：
```c
typedef struct {
    uint8_t id;           // AprilTag ID (0=中性, 1=蓝方, 2=黄方)
    float x, y;           // 相对位置
    float distance;       // 距离
    float angle;          // 角度偏差
} AprilTag_t;

void EnergyBlock_Process(void) {
    AprilTag_t target;

    // 从视觉系统获取目标
    if (Vision_GetTarget(&target)) {
        // 判断是否为有效目标
        if (target.id == 0 || target.id == robot_team_id) {
            // 对准能量块
            if (fabs(target.angle) > ALIGN_ANGLE_THRESHOLD) {
                // 调整角度
                if (target.angle > 0) {
                    Motor_SetSpeed(ALIGN_SPEED, -ALIGN_SPEED);
                } else {
                    Motor_SetSpeed(-ALIGN_SPEED, ALIGN_SPEED);
                }
            } else {
                // 接近能量块
                if (target.distance > PUSH_DISTANCE_THRESHOLD) {
                    Motor_SetSpeed(APPROACH_SPEED, APPROACH_SPEED);
                } else {
                    // 推送至边缘
                    Motor_SetSpeed(PUSH_SPEED, PUSH_SPEED);

                    // 检测到边缘后停止
                    if (Location_GetZone() == ZONE_EDGE) {
                        Motor_Stop();
                        // 后退脱离
                        Motor_SetSpeed(-PUSH_SPEED, -PUSH_SPEED);
                        HAL_Delay(500);
                        Motor_Stop();
                    }
                }
            }
        }
    } else {
        // 无目标：扫描模式
        Motor_SetSpeed(SCAN_SPEED, -SCAN_SPEED);
    }
}
```

---

## 七、软件架构

### 7.1 主循环结构

裸机架构采用"定时器中断+主循环"模式，主循环负责状态机执行和决策。

**主循环框架**：
```c
int main(void) {
    // 系统初始化
    HAL_Init();
    SystemClock_Config();

    // 外设初始化
    GPIO_Init();
    TIM_Init();
    ADC_Init();
    UART_Init();

    // 模块初始化
    Sensor_Init();
    Motor_Init();
    Vision_Init();

    // 启动定时器中断（2ms）
    HAL_TIM_Base_Start_IT(&htim2);

    // 主循环
    while (1) {
        // 软启动处理
        if (start_state != START_RUNNING) {
            SoftStart_Process();
            continue;
        }

        // 位置检测更新
        Location_Update();

        // 掉台恢复优先级最高
        if (location_state == LOCATION_OFF_ARENA) {
            FallRecover_Process();
            continue;
        }

        // 模式切换检测
        Mode_Switch_Check();

        // 执行当前模式状态机
        if (work_mode == MODE_COMBAT) {
            Combat_StateMachine();
        } else {
            Collect_StateMachine();
        }

        // 通信处理（视觉数据接收）
        Vision_DataProcess();

        // 调试信息输出
        Debug_Output();
    }
}
```

### 7.2 定时器中断

2ms定时器中断负责传感器采集和底层控制，保证实时性。

**中断服务函数**：
```c
void HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef *htim) {
    if (htim->Instance == TIM2) {
        // 灰度传感器采集
        Gray_Sensor.lf = ADC_Read(ADC_GRAY_LF);
        Gray_Sensor.rf = ADC_Read(ADC_GRAY_RF);
        Gray_Sensor.lb = ADC_Read(ADC_GRAY_LB);
        Gray_Sensor.rb = ADC_Read(ADC_GRAY_RB);

        // 红外传感器采集
        IR_Distance_Left = ADC_Read(ADC_IR_DIST_L);
        IR_Distance_Right = ADC_Read(ADC_IR_DIST_R);
        IR_Obstacle_Left = GPIO_ReadPin(IR_OBS_L_PORT, IR_OBS_L_PIN);
        IR_Obstacle_Right = GPIO_ReadPin(IR_OBS_R_PORT, IR_OBS_R_PIN);

        // 滤波处理（简单滑动平均）
        Sensor_Filter();

        // 电机PWM更新
        Motor_PWM_Update();

        // 系统时间计数
        system_tick++;
    }
}
```

### 7.3 模块划分

软件按功能划分为独立模块，便于开发和维护。

**模块结构**：
```
├── main.c                  // 主程序
├── sensor/
│   ├── gray_sensor.c       // 灰度传感器
│   ├── ir_sensor.c         // 红外传感器
│   └── sensor_filter.c     // 传感器滤波
├── actuator/
│   ├── motor.c             // 电机控制
│   └── servo.c             // 舵机控制（如有）
├── algorithm/
│   ├── location.c          // 位置检测算法
│   ├── track_zone.c        // 三轨道划分
│   └── direction.c         // 擂台方向识别
├── control/
│   ├── combat_fsm.c        // 战斗模式状态机
│   ├── collect_fsm.c       // 收集模式状态机
│   └── mode_switch.c       // 模式切换
├── function/
│   ├── soft_start.c        // 软启动
│   ├── climb.c             // 登台逻辑
│   ├── recover.c           // 掉台恢复
│   ├── edge_avoid.c        // 边缘避让
│   ├── attack.c            // 攻击逻辑
│   └── energy_block.c      // 能量块处理
├── communication/
│   ├── vision_uart.c       // 视觉通信
│   └── debug_uart.c        // 调试串口
└── config/
    ├── config.h            // 全局配置
    └── params.h            // 参数定义
```

**模块接口示例**：
```c
// sensor/gray_sensor.h
void Gray_Sensor_Init(void);
void Gray_Sensor_Read(void);
uint16_t Gray_Get_Average(void);
uint16_t Gray_Get_Variance(void);

// algorithm/location.h
void Location_Init(void);
void Location_Update(void);
LocationState_t Location_GetState(void);
TrackZone_t Location_GetZone(void);
ArenaDirection_t Location_GetDirection(void);

// control/combat_fsm.h
void Combat_Init(void);
void Combat_StateMachine(void);
CombatState_t Combat_GetState(void);
```

### 7.4 数据流

数据从传感器采集到决策执行的完整流程。

**数据流图**：
```
传感器层（2ms中断）
    ├─ 灰度传感器 ──┐
    ├─ 红外测距 ────┤
    └─ 红外避障 ────┤
                    ▼
              滤波处理
                    │
                    ▼
算法层（主循环）
    ├─ 位置检测算法 ──► location_state, track_zone, direction
    ├─ 敌人检测算法 ──► enemy_distance, enemy_direction
    └─ 视觉数据解析 ──► apriltag_id, target_position
                    │
                    ▼
决策层（主循环）
    ├─ 模式切换逻辑 ──► work_mode (COMBAT/COLLECT)
    ├─ 战斗状态机 ────► combat_state
    └─ 收集状态机 ────► collect_state
                    │
                    ▼
执行层（主循环+中断）
    ├─ 电机速度设置 ──► motor_left_speed, motor_right_speed
    └─ PWM输出（中断）──► TIM_PWM_CH1, TIM_PWM_CH2
```

**关键数据结构**：
```c
// 全局状态变量
typedef struct {
    // 启动状态
    StartState_t start_state;

    // 工作模式
    WorkMode_t work_mode;

    // 位置信息
    LocationState_t location_state;
    TrackZone_t track_zone;
    ArenaDirection_t arena_direction;

    // 传感器数据
    GraySensor_t gray_sensor;
    IRSensor_t ir_sensor;

    // 状态机状态
    CombatState_t combat_state;
    CollectState_t collect_state;

    // 视觉数据
    AprilTag_t vision_target;
    bool vision_valid;

    // 电机控制
    int16_t motor_left_speed;
    int16_t motor_right_speed;

    // 时间戳
    uint32_t system_tick;
} RobotState_t;

extern RobotState_t robot_state;
```

---

## 八、关键参数配置

### 8.1 传感器阈值

传感器阈值参数用于判断台上/台下、检测敌人、触发启动等。

**灰度传感器阈值**：
```c
// config/params.h

// 灰度传感器阈值
#define GRAY_ON_ARENA_MIN       2000    // 台上最小灰度值
#define GRAY_OFF_ARENA_MAX      1000    // 台下最大灰度值
#define GRAY_VARIANCE_THRESHOLD 500     // 方差阈值（台上>阈值）

// 三轨道划分阈值
#define ZONE_CENTER_VARIANCE    1500    // 中心区域方差阈值
#define ZONE_MIDDLE_VARIANCE    800     // 中间区域方差阈值
// EDGE区域：方差 < ZONE_MIDDLE_VARIANCE

// 擂台方向识别阈值
#define DIRECTION_DIFF_THRESHOLD 300    // 前后灰度差阈值
```

**红外传感器阈值**：
```c
// 红外测距阈值（单位：ADC值，对应实际距离需标定）
#define IR_DIST_ENEMY_NEAR      800     // 敌人近距离（<10cm）
#define IR_DIST_ENEMY_MID       400     // 敌人中距离（10-30cm）
#define IR_DIST_ENEMY_FAR       200     // 敌人远距离（30-50cm）

// 红外避障阈值
#define IR_START_THRESHOLD      100     // 启动信号阈值
#define IR_WALL_THRESHOLD       150     // 墙壁检测阈值
#define IR_OBSTACLE_THRESHOLD   200     // 障碍物检测阈值
```

**视觉系统阈值**：
```c
// AprilTag识别参数
#define VISION_VALID_TIMEOUT    500     // 视觉数据有效超时（ms）
#define ALIGN_ANGLE_THRESHOLD   5.0f    // 对准角度阈值（度）
#define PUSH_DISTANCE_THRESHOLD 15.0f   // 推送距离阈值（cm）
#define TARGET_LOST_TIMEOUT     2000    // 目标丢失超时（ms）
```

### 8.2 电机速度参数

电机速度参数控制机器人在不同状态下的运动速度。

**速度参数定义**：
```c
// 电机速度范围：-1000 ~ 1000（PWM占空比）

// 登台相关速度
#define CLIMB_MAX_SPEED         1000    // 登台最大速度（全速冲台）
#define CLIMB_ALIGN_SPEED       300     // 登台对准速度

// 战斗模式速度
#define ATTACK_MAX_SPEED        1000    // 攻击最大速度
#define ATTACK_APPROACH_SPEED   600     // 接近速度
#define SEARCH_SPEED            400     // 搜索旋转速度
#define PATROL_SPEED            500     // 巡逻速度

// 边缘避让速度
#define EDGE_AVOID_SPEED_LOW    300     // 中心区域避让速度
#define EDGE_AVOID_SPEED_MID    500     // 中间区域避让速度
#define EDGE_AVOID_SPEED_HIGH   700     // 边缘区域避让速度

// 掉台恢复速度
#define RECOVER_FORWARD_SPEED   400     // 恢复前进速度
#define RECOVER_ALIGN_SPEED     300     // 恢复对准速度

// 收集模式速度
#define SCAN_SPEED              300     // 扫描旋转速度
#define APPROACH_SPEED          400     // 接近能量块速度
#define ALIGN_SPEED             250     // 对准调整速度
#define PUSH_SPEED              600     // 推送速度
```

**速度控制函数**：
```c
// actuator/motor.c

void Motor_SetSpeed(int16_t left_speed, int16_t right_speed) {
    // 限幅
    left_speed = CLAMP(left_speed, -1000, 1000);
    right_speed = CLAMP(right_speed, -1000, 1000);

    // 设置方向和PWM
    if (left_speed >= 0) {
        GPIO_WritePin(MOTOR_L_DIR_PORT, MOTOR_L_DIR_PIN, GPIO_PIN_SET);
        TIM_SetPWM(TIM_MOTOR_L, left_speed);
    } else {
        GPIO_WritePin(MOTOR_L_DIR_PORT, MOTOR_L_DIR_PIN, GPIO_PIN_RESET);
        TIM_SetPWM(TIM_MOTOR_L, -left_speed);
    }

    if (right_speed >= 0) {
        GPIO_WritePin(MOTOR_R_DIR_PORT, MOTOR_R_DIR_PIN, GPIO_PIN_SET);
        TIM_SetPWM(TIM_MOTOR_R, right_speed);
    } else {
        GPIO_WritePin(MOTOR_R_DIR_PORT, MOTOR_R_DIR_PIN, GPIO_PIN_RESET);
        TIM_SetPWM(TIM_MOTOR_R, -right_speed);
    }
}
```

### 8.3 时间参数

时间参数控制状态持续时间、超时判断等。

**时间参数定义**：
```c
// 启动相关时间
#define START_DELAY_TIME        5000    // 启动延迟时间（ms）

// 登台相关时间
#define CLIMB_TIMEOUT           3000    // 登台超时时间（ms）
#define CLIMB_RETRY_DELAY       1000    // 登台重试延迟（ms）

// 战斗模式时间
#define SEARCH_TIMEOUT          5000    // 搜索超时（切换策略）
#define ATTACK_DURATION         2000    // 攻击持续时间
#define EVADE_DURATION          1000    // 回避持续时间
#define STUCK_TIMEOUT           3000    // 卡死判断超时

// 收集模式时间
#define SCAN_TIMEOUT            10000   // 扫描超时
#define APPROACH_TIMEOUT        5000    // 接近超时
#define ALIGN_TIMEOUT           3000    // 对准超时
#define PUSH_DURATION           2000    // 推送持续时间

// 模式切换时间
#define MODE_SWITCH_COOLDOWN    5000    // 模式切换冷却时间

// 传感器采样时间
#define SENSOR_SAMPLE_PERIOD    2       // 传感器采样周期（ms）
#define SENSOR_FILTER_SIZE      5       // 滤波窗口大小
```

**超时检测宏**：
```c
// 超时检测辅助宏
#define IS_TIMEOUT(start_tick, timeout_ms) \
    ((HAL_GetTick() - (start_tick)) >= (timeout_ms))

// 使用示例
static uint32_t search_start_tick = 0;

if (combat_state == COMBAT_SEARCH) {
    if (search_start_tick == 0) {
        search_start_tick = HAL_GetTick();
    }

    if (IS_TIMEOUT(search_start_tick, SEARCH_TIMEOUT)) {
        // 搜索超时，切换策略
        combat_state = COMBAT_PATROL;
        search_start_tick = 0;
    }
}
```

### 8.4 位置判断参数

位置判断参数用于台上/台下检测、三轨道划分、方向识别。

**位置判断参数**：
```c
// 台上/台下判断参数
#define LOCATION_CHECK_COUNT    3       // 连续检测次数（防抖）
#define LOCATION_STABLE_TIME    50      // 位置稳定时间（ms）

// 三轨道划分参数（基于灰度方差）
typedef struct {
    uint16_t center_min;    // 中心区域最小方差
    uint16_t middle_min;    // 中间区域最小方差
    uint16_t edge_max;      // 边缘区域最大方差
} ZoneThreshold_t;

const ZoneThreshold_t zone_threshold = {
    .center_min = 1500,
    .middle_min = 800,
    .edge_max = 800
};

// 擂台方向识别参数
#define DIRECTION_FRONT_BIAS    1.2f    // 前向灰度权重
#define DIRECTION_REAR_BIAS     1.0f    // 后向灰度权重
#define DIRECTION_CHECK_COUNT   5       // 方向检测次数

// 边缘检测灵敏度
typedef enum {
    EDGE_SENSITIVITY_LOW,       // 低灵敏度（中心区域）
    EDGE_SENSITIVITY_MEDIUM,    // 中灵敏度（中间区域）
    EDGE_SENSITIVITY_HIGH       // 高灵敏度（边缘区域）
} EdgeSensitivity_t;
```

**参数配置表**：
```c
// 综合参数配置表
typedef struct {
    // 传感器阈值
    struct {
        uint16_t gray_on_arena_min;
        uint16_t gray_variance_threshold;
        uint16_t ir_enemy_near;
        uint16_t ir_enemy_mid;
    } sensor;

    // 速度参数
    struct {
        int16_t climb_max;
        int16_t attack_max;
        int16_t search_speed;
        int16_t push_speed;
    } speed;

    // 时间参数
    struct {
        uint32_t start_delay;
        uint32_t climb_timeout;
        uint32_t search_timeout;
        uint32_t stuck_timeout;
    } time;

    // 位置参数
    struct {
        uint16_t zone_center_min;
        uint16_t zone_middle_min;
        uint8_t location_check_count;
    } location;
} RobotConfig_t;

// 默认配置
const RobotConfig_t default_config = {
    .sensor = {
        .gray_on_arena_min = 2000,
        .gray_variance_threshold = 500,
        .ir_enemy_near = 800,
        .ir_enemy_mid = 400
    },
    .speed = {
        .climb_max = 1000,
        .attack_max = 1000,
        .search_speed = 400,
        .push_speed = 600
    },
    .time = {
        .start_delay = 5000,
        .climb_timeout = 3000,
        .search_timeout = 5000,
        .stuck_timeout = 3000
    },
    .location = {
        .zone_center_min = 1500,
        .zone_middle_min = 800,
        .location_check_count = 3
    }
};
```

---

## 九、调试接口

### 9.1 串口调试

通过UART串口实现调试信息输出和参数配置。

**串口配置**：
```c
// communication/debug_uart.c

// 串口配置参数
#define DEBUG_UART              USART1
#define DEBUG_UART_BAUDRATE     115200
#define DEBUG_UART_TX_PIN       GPIO_PIN_9
#define DEBUG_UART_RX_PIN       GPIO_PIN_10

// 初始化调试串口
void Debug_UART_Init(void) {
    UART_HandleTypeDef huart1;

    huart1.Instance = USART1;
    huart1.Init.BaudRate = 115200;
    huart1.Init.WordLength = UART_WORDLENGTH_8B;
    huart1.Init.StopBits = UART_STOPBITS_1;
    huart1.Init.Parity = UART_PARITY_NONE;
    huart1.Init.Mode = UART_MODE_TX_RX;

    HAL_UART_Init(&huart1);
}

// 发送调试信息
void Debug_Printf(const char *format, ...) {
    char buffer[128];
    va_list args;

    va_start(args, format);
    vsnprintf(buffer, sizeof(buffer), format, args);
    va_end(args);

    HAL_UART_Transmit(&huart1, (uint8_t*)buffer, strlen(buffer), 100);
}
```

**调试命令协议**：
```c
// 命令格式：CMD:PARAM\r\n

typedef enum {
    CMD_GET_STATE,      // 获取状态：GET:STATE
    CMD_SET_MODE,       // 设置模式：SET:MODE:0/1
    CMD_SET_SPEED,      // 设置速度：SET:SPEED:L:R
    CMD_GET_SENSOR,     // 获取传感器：GET:SENSOR
    CMD_SET_PARAM,      // 设置参数：SET:PARAM:NAME:VALUE
    CMD_RESET           // 复位：RESET
} DebugCommand_t;

void Debug_CommandProcess(char *cmd) {
    if (strncmp(cmd, "GET:STATE", 9) == 0) {
        Debug_PrintState();
    } else if (strncmp(cmd, "SET:MODE:", 9) == 0) {
        work_mode = (cmd[9] == '1') ? MODE_COLLECT : MODE_COMBAT;
        Debug_Printf("Mode set to %d\r\n", work_mode);
    } else if (strncmp(cmd, "GET:SENSOR", 10) == 0) {
        Debug_PrintSensor();
    } else if (strncmp(cmd, "RESET", 5) == 0) {
        NVIC_SystemReset();
    }
}
```

### 9.2 状态监控

实时监控机器人状态，便于调试和问题定位。

**状态输出函数**：
```c
// 输出完整状态信息
void Debug_PrintState(void) {
    Debug_Printf("=== Robot State ===\r\n");
    Debug_Printf("Start: %d\r\n", start_state);
    Debug_Printf("Mode: %s\r\n", work_mode == MODE_COMBAT ? "COMBAT" : "COLLECT");
    Debug_Printf("Location: %s\r\n",
        location_state == LOCATION_ON_ARENA ? "ON" : "OFF");
    Debug_Printf("Zone: %d\r\n", track_zone);
    Debug_Printf("Combat State: %d\r\n", combat_state);
    Debug_Printf("Collect State: %d\r\n", collect_state);
    Debug_Printf("Motor: L=%d R=%d\r\n",
        motor_left_speed, motor_right_speed);
    Debug_Printf("==================\r\n");
}

// 输出传感器数据
void Debug_PrintSensor(void) {
    Debug_Printf("=== Sensor Data ===\r\n");
    Debug_Printf("Gray: LF=%d RF=%d LB=%d RB=%d\r\n",
        Gray_Sensor.lf, Gray_Sensor.rf,
        Gray_Sensor.lb, Gray_Sensor.rb);
    Debug_Printf("Gray Avg=%d Var=%d\r\n",
        Gray_Sensor.avg, Gray_Sensor.variance);
    Debug_Printf("IR Dist: L=%d R=%d\r\n",
        IR_Distance_Left, IR_Distance_Right);
    Debug_Printf("IR Obs: L=%d R=%d\r\n",
        IR_Obstacle_Left, IR_Obstacle_Right);
    Debug_Printf("==================\r\n");
}

// 输出视觉数据
void Debug_PrintVision(void) {
    if (vision_valid) {
        Debug_Printf("Vision: ID=%d Dist=%.2f Angle=%.2f\r\n",
            vision_target.id,
            vision_target.distance,
            vision_target.angle);
    } else {
        Debug_Printf("Vision: No target\r\n");
    }
}
```

**周期性状态输出**：
```c
// 在主循环中周期性输出状态
void Debug_Output(void) {
    static uint32_t last_output_tick = 0;

    // 每500ms输出一次状态
    if (HAL_GetTick() - last_output_tick >= 500) {
        Debug_PrintState();
        Debug_PrintSensor();
        last_output_tick = HAL_GetTick();
    }
}
```

### 9.3 参数调整

支持运行时在线调整参数，无需重新编译。

**参数调整接口**：
```c
// 参数调整命令
typedef struct {
    const char *name;
    void *ptr;
    uint8_t type;  // 0=uint16_t, 1=int16_t, 2=uint32_t
} ParamItem_t;

const ParamItem_t param_table[] = {
    {"GRAY_THRESHOLD", &GRAY_VARIANCE_THRESHOLD, 0},
    {"ATTACK_SPEED", &ATTACK_MAX_SPEED, 1},
    {"CLIMB_SPEED", &CLIMB_MAX_SPEED, 1},
    {"SEARCH_TIMEOUT", &SEARCH_TIMEOUT, 2},
    // ... 更多参数
};

// 设置参数
void Debug_SetParam(const char *name, int32_t value) {
    for (int i = 0; i < sizeof(param_table)/sizeof(ParamItem_t); i++) {
        if (strcmp(param_table[i].name, name) == 0) {
            switch (param_table[i].type) {
                case 0:
                    *(uint16_t*)param_table[i].ptr = (uint16_t)value;
                    break;
                case 1:
                    *(int16_t*)param_table[i].ptr = (int16_t)value;
                    break;
                case 2:
                    *(uint32_t*)param_table[i].ptr = (uint32_t)value;
                    break;
            }
            Debug_Printf("Set %s = %d\r\n", name, value);
            return;
        }
    }
    Debug_Printf("Param not found: %s\r\n", name);
}

// 获取参数
void Debug_GetParam(const char *name) {
    for (int i = 0; i < sizeof(param_table)/sizeof(ParamItem_t); i++) {
        if (strcmp(param_table[i].name, name) == 0) {
            int32_t value;
            switch (param_table[i].type) {
                case 0:
                    value = *(uint16_t*)param_table[i].ptr;
                    break;
                case 1:
                    value = *(int16_t*)param_table[i].ptr;
                    break;
                case 2:
                    value = *(uint32_t*)param_table[i].ptr;
                    break;
            }
            Debug_Printf("%s = %d\r\n", name, value);
            return;
        }
    }
    Debug_Printf("Param not found: %s\r\n", name);
}
```

**参数保存到Flash**：
```c
// 将参数保存到Flash
#define FLASH_PARAM_ADDR    0x0800F000  // Flash最后一页

void Param_SaveToFlash(void) {
    HAL_FLASH_Unlock();

    // 擦除页
    FLASH_EraseInitTypeDef erase;
    erase.TypeErase = FLASH_TYPEERASE_PAGES;
    erase.PageAddress = FLASH_PARAM_ADDR;
    erase.NbPages = 1;
    uint32_t error;
    HAL_FLASHEx_Erase(&erase, &error);

    // 写入参数
    HAL_FLASH_Program(FLASH_TYPEPROGRAM_WORD,
        FLASH_PARAM_ADDR, *(uint32_t*)&default_config);

    HAL_FLASH_Lock();
    Debug_Printf("Params saved to Flash\r\n");
}

// 从Flash加载参数
void Param_LoadFromFlash(void) {
    uint32_t *flash_data = (uint32_t*)FLASH_PARAM_ADDR;
    if (*flash_data != 0xFFFFFFFF) {
        memcpy(&default_config, flash_data, sizeof(RobotConfig_t));
        Debug_Printf("Params loaded from Flash\r\n");
    }
}
```

### 9.4 日志输出

记录关键事件和错误信息，便于问题追踪。

**日志系统**：
```c
// 日志级别
typedef enum {
    LOG_ERROR,
    LOG_WARN,
    LOG_INFO,
    LOG_DEBUG
} LogLevel_t;

// 日志配置
#define LOG_LEVEL           LOG_INFO    // 当前日志级别
#define LOG_BUFFER_SIZE     512         // 日志缓冲区大小

// 日志输出宏
#define LOG_E(fmt, ...) Log_Print(LOG_ERROR, "[ERROR] " fmt, ##__VA_ARGS__)
#define LOG_W(fmt, ...) Log_Print(LOG_WARN,  "[WARN]  " fmt, ##__VA_ARGS__)
#define LOG_I(fmt, ...) Log_Print(LOG_INFO,  "[INFO]  " fmt, ##__VA_ARGS__)
#define LOG_D(fmt, ...) Log_Print(LOG_DEBUG, "[DEBUG] " fmt, ##__VA_ARGS__)

// 日志输出函数
void Log_Print(LogLevel_t level, const char *format, ...) {
    if (level > LOG_LEVEL) return;

    char buffer[128];
    va_list args;

    // 添加时间戳
    uint32_t tick = HAL_GetTick();
    int len = snprintf(buffer, sizeof(buffer), "[%6lu] ", tick);

    // 添加日志内容
    va_start(args, format);
    vsnprintf(buffer + len, sizeof(buffer) - len, format, args);
    va_end(args);

    // 输出到串口
    Debug_Printf("%s\r\n", buffer);
}
```

**关键事件日志**：
```c
// 在关键位置添加日志

// 状态切换日志
void Combat_StateMachine(void) {
    static CombatState_t last_state = COMBAT_INIT;

    if (combat_state != last_state) {
        LOG_I("Combat state: %d -> %d", last_state, combat_state);
        last_state = combat_state;
    }

    // ... 状态机逻辑
}

// 掉台事件日志
void Location_Update(void) {
    static LocationState_t last_location = LOCATION_ON_ARENA;

    if (location_state == LOCATION_OFF_ARENA &&
        last_location == LOCATION_ON_ARENA) {
        LOG_W("Robot fell off arena!");
    }

    last_location = location_state;
}

// 错误日志
void Motor_SetSpeed(int16_t left, int16_t right) {
    if (abs(left) > 1000 || abs(right) > 1000) {
        LOG_E("Motor speed out of range: L=%d R=%d", left, right);
        return;
    }
    // ... 设置速度
}
```

**调试命令总结**：
```
串口命令列表：
- GET:STATE          获取机器人状态
- GET:SENSOR         获取传感器数据
- GET:VISION         获取视觉数据
- SET:MODE:0/1       设置模式（0=战斗，1=收集）
- SET:SPEED:L:R      设置电机速度
- SET:PARAM:NAME:VAL 设置参数
- GET:PARAM:NAME     获取参数
- SAVE:PARAM         保存参数到Flash
- LOAD:PARAM         从Flash加载参数
- RESET              系统复位
```

